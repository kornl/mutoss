% 
\documentclass[a4paper]{article}
\usepackage[OT1]{fontenc}
\usepackage{Sweave}
\usepackage{amssymb}

\newcommand{\sT}{simTool}

\begin{document}

\title{\sT}
\author{MarselScheer}



\maketitle

<<echo=FALSE>>=
	require(mutoss)
@
This document will give an introduction to the use of \sT. 
We will start with a very simple application then raise the
degree of complexity in a few steps and in the end reproduce 
some of the results from Benjamini, Krieger, Yekutieli (2006).
Basically for a simulation we need the following things
\begin{enumerate}
\item a function that generates the data (for example pValues)
\item some procedures that evaluates the generated data (for example the bonferroni correction)
\item statistics we want to calculate (for example the estimated value of the FDR).
\end{enumerate}
If we are speak of for example of $1000$ replications, we mean that these 3 steps
were repeated $1000$ times. That means, after $1000$ replications there have been
$1000$ data sets generated. Every procedure was applied to these $1000$ data sets.
If we have specified for example $3$ procedures then every of these procedure
will give us an output, this means $3000$ "output objects". And every specified
statistic is applied to these $3000$ "output objects". \\ 



\subsection{Data generating function}
\label{DataGenFun}
The following function generates data and will be used throughout the whole
document. A data generating function must return a list with specific elements.
One element of the list must be \$groundTruth. If the function like this one
generates pValues the list must contain an element \$pValues. The next section
\ref{MutossSimClass} will clarify which elements of the returned list are feasible. 
<<>>=
	pValFromEquiCorrData <- function(sampleSize, rho, mu, pi0)
	{		
		nmbOfFalseHyp <- round(sampleSize * (1-pi0))
		nmbOfTrueHyp <- sampleSize - nmbOfFalseHyp
		muVec <- c(rep(mu, nmbOfFalseHyp), rep(0, nmbOfTrueHyp))
		Y <- sqrt(rho) * rnorm(1) + sqrt(1-rho) * rnorm(sampleSize) + muVec
		return(list(
			pValues = 1 - pnorm(Y),
			groundTruth = muVec == 0
			)
		)
	}
@




\subsection{MutossSim Class}
\label{MutossSimClass}
The MutossSim object has 3 purposes. For now we will focus only on 2 of them. 
\subsubsection{Keep track of input and output}
First, if data is generated by the specific function, let us call this function for a moment dataGen(), 
the output of dataGen() will be automatically stored in a MutossSim object. To assure that
this can be done automatically the names of the list returned must be a subset of the slotNames of the
MutossSim object.
<<>>=
	slotNames(new("MutossSim"))
@
The slot @idx should not be touched by the user. This slot is reserved for 
internal use only and is part of the third purpose of the MutossSim class, 
that will be explained later. Let's have a look at the list returned by the
function pValFromEquiCorrData from section \ref{DataGenFun}. The purpose of
this function is to generate pValues that correspond to some hypotheses, some
of them true and some of them false. The MutossSim class has a slot @pValues, thus
one name of the returned list is pValues. Also for simulation it is necessary to
know which pValues correspond to a true hypotheses and which belong to false ones.
For this purpose the MutossSim class has the slot @groundTruth, thus the other name 
of the returned list is groundTruth.\\
In the same way the output from the procedures are automatically written into the 
MutossSim object. The procedures from the mutoss library can directly be used, because
they already use this name convention. But if one has to write a new procedure one need
to take care of the names of the returned list in the same way like for the data generating 
function.

\subsubsection{Keep track of parameters used}
Another slot that is for internal use only is @parameters. Usually the used 
data generating function and the used procedures are controlled by parameters. To keep
track of the parameters used for every MutossSim object the slot @parameters will 
be automatically filled. The information in this slot is later used to group the bunch
of MutossSim objects created during the simulation. All MutossSim objects that have
the same content in @parameter will be considered as one group of MutossSim objects.\\





\subsection{Statistics for MutossSim objects}
Of course we want at every replication step calculate some statistics like the number
of rejected pValues ($R$) the number of rejected true pValues ($V$), the realized FDP
($\frac{V}{\max(R,1)}$), the realized FWER ($I_{\{V > 0\}}$) and so on. All information
needed is stored in a uniform way in the MutossSim object. If want to write a function
that calculates the number of rejected true pValues it must take a MutossSim object as
an argument and calculate from this $V$. It could look like this:
<<>>=
	V <- function(mts) sum(mts@rejected * mts@groundTruth)
@





\subsection{First simple simulations}
Even though the first example is very simple it is rather long because the basic concept 
of the functions simulation and gatherStatistics will be explained in this first example. 
\subsubsection{Very simple}
The theory says that "bonferroni" controls the family wise error rate in the strong sense.
Let`s look if this is "true". We will generate uncorrelated pValues, plug them into the bonferroni
procedure and evaluate if the number of rejected true hypotheses is greater than $0$ ($V>0$). An function
that generates the data already exists. Also we have already a function called V that takes a MutossSim
object and calculates from the slots @rejected and @groundTruth the number of rejected true
hypotheses. With a view to performance it would probably better to write the function V.ge.0 from scratch
but we will reuse the function V.
<<>>=
	V.ge.0 <- function(mts) V(mts) > 0
@
To prevent ourselves against getting lost in to many MutossSim objects we start with a very small
simulation study with only 10 replications.
<<>>=
	sim <- simulation(replications = 10,
			list(funName = "MyDataGenFun",
					fun = pValFromEquiCorrData,
					sampleSize = 100,
					rho = 0,
					mu = 0,
					pi0 = 1
			),
			list(
					list(funName = "bonf.",
							fun = bonferroni,
							alpha = 0.5
					)
			)
	)
	print(length(sim))
@
The variable \emph{sim} is a list of 10 MutossSim objects. What happend (10 times ) 
is the following:
\begin{enumerate}
\item create a new MutossSim object, called mts.
\item call pValFromEquiCorrData(sampleSize = 100, rho = 0, mu = 0, nmbOfFalseHyp = 0)
\item write the output of this function call, that is pValues and groundTruth, into mts
\item call bonferroni(mts@pValues, alpha = 0.5)
\item write the output of this function call, that is adjPValues and rejected, into mts
\item append mts to the resulting list.
\end{enumerate}
How do we now get the statistic V.ge.0 into play. There is the function gatherStatistics that
do the work for us. Actually this function is able to do two jobs for us. The first one
is to calculate for every MutossSim object the statistics we provide. It will create a 
data.frame, named \$statisticDF, where every row stands for one MutossSim object. The columns consist of 
parameters used in the simulation study and the calculated statistics. Let's have a look at the output
<<>>=
	result.all <- gatherStatistics(
			sim, 
			list(V.greater.Zero = V.ge.0)
	)
	print(result.all)
@
The list returned by gatherStatistics has some additional information. The entry \$name.parameters
contains the name of the parameters used for controlling the data generating function and procedures. 
And the entry \$name.statistics contains the label for the used statistics.\\
The second job is quite similar and the output is quite similiar. The only difference is that we
additionally provide an "average function".
<<>>=
	result <- gatherStatistics(
			sim, 
			list(V.greater.Zero = V.ge.0), 
			list(MEAN = mean)
	)
	print(result)
@
So all rows are collapsed into one row, because we only have one parameter constellation,
and the mean of the column V.greater.Zero is calculated.

\subsubsection{Extending the very simple case}
We will extend this simple example in a way that we will have more than one parameter constellation. 
At the moment in our simulation study the correlation $\rho$ is always zero and we apply the bonferroni 
only at level $0.5$. Suppose for example that we want to investigate the case where the correlation 
equals $0$ and $0.2$ and apply bonferroni at level $0.5$ and $0.75$. Futher more we want also use
Holm's procedure, but only at level $0.1$. Then only the following changes are necessary.  
<<>>=
	sim <- simulation(replications = 10,
			list(funName = "MyDataGenFun",
					fun = pValFromEquiCorrData,
					sampleSize = 100,
					rho = c(0, 0.2),
					mu = 0,
					pi0 = 1
			),
			list(
					list(funName = "bonf.",
							fun = bonferroni,
							alpha = c(0.5, 0.75)
					),
					list(funName = "HOLM",
							fun = function(pValues, alpha) holm(pValues, alpha, silent=TRUE),
							alpha = 0.1
					)
	
			)
	)
	print(length(sim))
@
Now $60$ MutossSim objects are created, because $10$ times 
pValFromEquiCorrData(sampleSize = 100, rho = 0, mu = 0, pi0 = 0) is used and then
bonferroni at level $0.5$ and at level $0.75$ is applied as well as holm at level $0.1$. 
These are $30$ MutossSim objects. After that
pValFromEquiCorrData(sampleSize = 100, rho = 0.2, mu = 0, pi0 = 0) is used and again
bonferroni at level $0.5$ and at $0.75$ is applied as well as holm at level $0.1$. 
This means we have $60$ MutossSim objects basing upon $20$ data sets.
We now directly use the "average function" mean, because without these "average function" the
resulting data.frame will have $60$ rows.
<<>>=
	result <- gatherStatistics(
			sim,
			list(V.greater.Zero = V.ge.0),
			list(MEAN = mean)
	)
	print(result)
@





\subsection{More complex simulation studies}
Suppose we want to investigate how the number of rejected true hypotheses ($V$) behaves under the
global null if the correlation increases and we use the procedure of Benjamini and Hochberg (1995) at
level $0.5$ and $0.75$.
<<>>=
	sim <- simulation(replications = 1000,
			list(funName = "MyDataGenFun",
					fun = pValFromEquiCorrData,
					sampleSize = 100,
					rho = seq(0, 1, by = 0.2),
					mu = 0,
					pi0 = 1
			),
			list(
					list(funName = "BH",
							fun = function(pValues, alpha) BH(pValues, alpha, silent=TRUE),
							alpha = c(0.5, 0.75)
					)	
			)
	)
	print(length(sim))
@
The are already different kind of R functions that take data.frames and generate plots from them.
Because we can calculate the statistics at the replication level, this means that the statistics
are calculated for every MutossSim object, we can generate histograms, boxplots and so on. For some
plot example we will need the lattice package.
<<>>=
	require(lattice)
@
First we calculate V for every MutossSim object and then plot a histogram and a boxplot of V, 
see Figure~\ref{fig:HistV1} (p.~\pageref{fig:HistV1}), Figure~\ref{fig:BWV1} (p.~\pageref{fig:BWV1}.
<<>>=
	result.all <- gatherStatistics(
			sim,
			list(V = V)
	)		
@
<<label=figHistV1,include=FALSE, echo=FALSE>>=
	print(histogram(~V | rho, data = subset(result.all$statisticDF, alpha=="0.5")))
@
\begin{figure}
\begin{center}
<<label=fig1,fig=TRUE,echo=TRUE>>=
<<figHistV1>>
@
\end{center}
\caption{Histogram of the number of rejected true hypotheses for alpha equals 0.5}
\label{fig:HistV1}
\end{figure}
<<label=figBWV1,include=FALSE, echo=FALSE>>=
	print(bwplot(V ~ rho | alpha, data = subset(result.all$statisticDF)))
@
\begin{figure}
\begin{center}
<<label=fig2,fig=TRUE,echo=TRUE>>=
<<figBWV1>>
@
\end{center}
\caption{Boxplot of the number of rejected true hypotheses}
\label{fig:BWV1}
\end{figure}
Also after the "average process" we again get an data.frame which can be used to generate 
plots.
<<>>=
	result <- gatherStatistics(
			sim,
			list(V = V),
			list(MEAN_l = function(x) mean(x) - 2 * sd(x)/sqrt(length(x)),
					MEAN_u = function(x) mean(x) + 2 * sd(x)/sqrt(length(x)),
					MEAN = mean, 
					SD = sd)
	)
	print(subset(result$statisticDF, alpha=="0.5"))
@
<<label=figXYPlot,include=FALSE, echo=FALSE>>=
	print(xyplot(V.MEAN_l + V.MEAN + V.MEAN_u ~ rho | alpha, data = result$statisticDF,
					type = "a",
					auto.key=list(space="right", points=FALSE, lines=TRUE)
			)
	)
@
\begin{figure}
\begin{center}
<<label=fig3,fig=TRUE,echo=TRUE>>=
<<figXYPlot>>
@
\end{center}
\caption{XYPlot of the mean number of rejected true hypotheses with 95\% confidence intervalls}
\label{fig:XYPlotV1}
\end{figure}




\subsection{Reproducing some results from BKY (2006)}
Now we will reproduce figure $1$ from the publication. For this we need to estimate the FDR. This
means, that we have to calculate the realized FDP for every MutossSim object. And then "mean(realizedFDP)"
will be the estimated FDR. The data generating function already exist. So we only need a function 
that calculates the realised FDP for us. To save some memory we split the simulation into 2 parts and
then "merge the gathered statistics".
<<>>=
	FDP <- function(mts) V(mts)/max(sum(mts@rejected),1)
@
No we can start simulating. We now do the simulation for $\pi_0 = m_0/m = 0.75$
<<>>=
	sim <- simulation(
			10000,
			list(funName = "MyDataGenFun",
					fun = pValFromEquiCorrData,
					sampleSize = c(16, 32, 64, 128, 256, 512),
					rho = c(0,0.1,0.5),
					mu = 5,
					pi0 = c(0.75)
			),
			list(
					list(funName = "LSU",
							fun = BH,
							alpha = 0.05,
							silent = TRUE
					),	
					#list(funName = "ABH",
					#		fun = adaptiveBH,
					#		alpha = 0.05,
					#		silent = TRUE
					#),	
					#list(funName = "TST",
					#		fun = twostageBKY,
					#		alpha = 0.05,
					#		silent = TRUE
					#),	
					#list(funName = "MST",
					#		fun = multistageBKY,
					#		alpha = 0.05,
					#		silent = TRUE
					#),	
					list(funName = "M-S-HLF",
							fun = adaptiveSTS,
							alpha = 0.05,							
							silent = TRUE
					)	
			)
	)
	result1 <- gatherStatistics(
			sim,
			list(FDP = FDP),
			mean
	)	
@
<<label=Fig1_pi0_1,fig=FALSE,echo=FALSE>>=
	print(xyplot(FDP.mean ~ sampleSize | pi0 * rho, data = result1$statisticDF, group=method,
			type = "a",
			auto.key=list(space="right", points=FALSE, lines=TRUE)
		)
	)
@
and for $\pi_0 = m_0/m = 0.25$
<<>>=
	sim <- simulation(
			10000,
			list(funName = "MyDataGenFun",
					fun = pValFromEquiCorrData,
					sampleSize = c(16, 32, 64, 128, 256, 512),
					rho = c(0,0.1,0.5),
					mu = 5,
					pi0 = c(0.25)
			),
			list(
					list(funName = "LSU",
							fun = BH,
							alpha = 0.05,
							silent = TRUE
					),	
					#list(funName = "ABH",
					#		fun = adaptiveBH,
					#		alpha = 0.05,
					#		silent = TRUE
					#),	
					#list(funName = "TST",
					#		fun = twostageBKY,
					#		alpha = 0.05,
					#		silent = TRUE
					#),	
					#list(funName = "MST",
					#		fun = multistageBKY,
					#		alpha = 0.05,
					#		silent = TRUE
					#),	
					list(funName = "M-S-HLF",
							fun = adaptiveSTS,
							alpha = 0.05,							
							silent = TRUE
					)	
			)
	)
	result2 <- gatherStatistics(
			sim,
			list(FDP = FDP),
			mean
	)
	rm(sim) 
@
If you compare the plots from this document with the publication you will notice that we
skipped some of the procedures. In fact we only simulate Storey's procedure (2004) and
Benjamini \& Hochberg (1995) procedure.
<<label=Fig1_pi0_2,fig=FALSE,echo=FALSE>>=
	print(xyplot(FDP.mean ~ sampleSize | pi0 * rho, data = result2$statisticDF, group=method,
			type = "a",
			auto.key=list(space="right", points=FALSE, lines=TRUE)
		)
	)
@
\begin{figure}
\begin{center}
<<label=Fig1_pi0_1,fig=TRUE,echo=TRUE>>=
<<Fig1_pi0_1>>
@
\end{center}
\caption{A part of figure 1 from BKY (2006)}
\label{fig:Fig1_pi0_1}
\end{figure}

\begin{figure}
\begin{center}
<<label=Fig1_pi0_2,fig=TRUE,echo=TRUE>>=
<<Fig1_pi0_2>>
@
\end{center}
\caption{A part of figure 1 from BKY (2006)}
\label{fig:Fig1_pi0_2}
\end{figure}
Of course the \$statisticDF from the variables \emph{result1} and \emph{result2} can be joined and then
plotted together see figure \ref{fig:joined}.
<<label=Fig1_pi0_joined,fig=FALSE,echo=FALSE>>=
	joinedStatisticDF <- rbind(result1$statisticDF, result2$statisticDF)
	print(xyplot(FDP.mean ~ sampleSize | pi0 * rho, data = joinedStatisticDF, group=method,
					type = "a",
					auto.key=list(space="right", points=FALSE, lines=TRUE)
			)
	)	
@
\begin{figure}
\begin{center}
<<label=Fig1_pi0_joined,fig=TRUE,echo=TRUE>>=
<<Fig1_pi0_joined>>
@
\end{center}
\caption{A part of figure 1 from BKY (2006)}
\label{fig:joined}
\end{figure}

\end{document}


